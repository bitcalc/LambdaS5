open Prelude
open Ljs_opt
open Ljs_syntax
open Debug
open Exp_util


(* if match successfully, this function will trim off
   the function object's properties and leave the function body
   and related let bindings.
*)
let rec get_lambda exp : exp option =
  (* if exp is an object whose #code is not null *)
  let is_proto_obj exp : bool = match exp with
    | Object (_, {proto=Some (Id (_, "%ObjectProto")); klass="Object"}, _) -> true
    | _ -> false
  in
  let get_js_func exp : exp option = match exp with
    | Object (_, {code=Some code}, _) -> Some code
    | _ -> None
  in
  let rec get_func exp : exp option = match exp with
    | Let (p, x, x_v, body) -> begin match get_js_func x_v with
        | Some code -> Some code
        | None ->
          (*this let binding is not what we are looking for, 
            keep it and continue looking. *)
          match get_func body with
          | Some code ->
            Some (Let (p, x, x_v, code))
          | None -> None
      end
    | _ -> None
  in
  match exp with
  | Let (_, x, x_v, body) when is_proto_obj x_v ->
    (* function object always starts with prototype and then lambda *)
    get_func body
  | _ -> None
      
(* env stores the id -> lambda code *)
type env = exp IdMap.t
  
(* This transformation will 
   1. restore function objects to procedures
   2. clean checks, especially 'typeof' generated by the desugarer.

   Still, passing a procedure as an argument will contruct an ArgsObj,
   which will call 'typeof' on the procedure. Therefore, this transformation
   makes sense only when it is used after fixed arity transformation.
*)
let restore_function exp : exp =
  let rec clean_checks (e : exp) : exp =
    match e with
    | Let (_, x, Op1(_, "typeof", _),
           If (_, Op1(_, "!", Op2(_, "stx=", this_x, String(_, "function"))),
               _,
               els)) when same_Id x this_x ->
      els
    | _ -> optimize clean_checks e
  in
  let rec restore_rec exp env : exp =
    let restore e = restore_rec e env in
    match exp with
    | Let (p, x, x_v, body) ->
      begin match get_lambda x_v with
        | Some (code) ->
          Let (p, x, restore code, restore body)
        | None ->
          Let (p, x, restore x_v, restore body)
      end
    | _ -> optimize restore exp
  in
  let procedures_with_checks = restore_rec exp IdMap.empty in
  clean_checks procedures_with_checks

